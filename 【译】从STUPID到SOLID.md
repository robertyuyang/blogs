
# 从STUPID到SOLID


##### 原文：https://williamdurand.fr/2013/07/30/from-stupid-to-solid-code/

上周我在我工作的公司——米其林公司做了一个关于面向对象编程（Object-Oriented Programming）的演讲。我讲到如何去编写更好的代码，如何从STUPID的代码转变成SOLID的代码。**STUPID**和**SOLID**都是两组缩写，已经被提出很长时间了，然而，这些理论还是不完全被所有人所熟知，因此还是很值得被发扬光大的。

下面的部分，我会把STUPID原则和SOLID原则都介绍一下。请记住这点：这些都**只是“原则”，而不是“法律”**。不过，想要做到自我提升的人最好能把它们当做法律去执行。

### STUPID代码，认真的吗？

这句话可能有点伤人：你很有可能已经写过STUPID代码了。其实我也写过，不过它们到底是什么意思呢？

- 单例(**S**ingleton)
- 紧耦合（**T**ight Coupling)
- 不可测试(**U**ntestability)
- 过早优化(**P**remature Optimization)
- 无意义的命名(**I**ndescriptive Naming)
- 冗余(**D**uplication)


下面，我会就每一个点更详细的解释一下，这些内容基本就是把我那次演讲再说一遍。

#### 单例（Singleton）

单例模式大概是最被知道的最多的设计模式了，但同时也是最被误解的设计模式。你听说过“单例综合证”吗？意思就是你总是觉得当前的情况特别适合用单例，换句话说，任何情况你都会觉得适合用单例。这肯定是**有问题的**。

单例模式其实是充满争议的，甚至是被认为是反设计模式的。甚至有人说应该尽量避免使用单例模式。但实际上，单例并不是问题本身，而是问题的症状（外部表现）。有两条理由支持为什么单例模式是有害的：

- 使用全局域的程序是很难测试的；
- 依赖于全局域的程序总是很难发现他们的依赖关系。

但是，我们真的要完全不使用单例吗？我认为是的，因为你总是能够用更好的方式去代替单例。避免这种静态域对避免**紧耦合**（Tight Coupling）也是非常重要的。

#### 紧耦合(Tight Coupling)

**紧耦合**，或者叫**强耦合**，是单例问题的一个泛化。基本上，你应该避免你模块之间的耦合。“耦合”是指程序中不同模块互相依赖的一个“度”。

如果为了修改一个模块需要你也修改另外一个模块，那么这里就存在耦合。比如，你在你类的构造函数里初始化一个实例，而不是通过参数把实例传进去。这就不是特别好，因为这样就**没办法做进一步的调整**，比如改成传一个子类对象进去，或者传一个mock对象（伪装对象）进去，等等。

紧耦合的模块是非常**难以重用**，同时也是**难以测试**的。

#### 不可测试（Untestability)

我认为，**测试应该是很容易的**。真的。每一次你认为你没有时间去写单元测试的时候，其实真正的原因都是你的代码写的不好，不过我们后面再细说。

绝大多数时候，**不可测试**都是因为**紧耦合**。

#### 过早优化(Premature Optimization)

Donald Knuth说过：“过早优化是所有罪恶的源泉，这个事情**只有成本没有收益**”。实际上优化是一个非常负责的事务，远比重写一个循环或者用++替换到i++要复杂的多。不好的优化往往最后都会造出一堆无法阅读的代码，这也是为什么过早优化也经常被认为是反设计模式的。

我的一个朋友经常说，优化一个程序的时候有两个原则：

- 不要优化；
- 晚点再优化。

#### 无意义的命名(Indescriptive Naming)

这一条就比较显而易见了，但仍值得说一下：给你们的类，方法，属性，变量合适的命名。千万不要简略。你的代码是写给人看的，不是给机器看的，机器本来也不懂你在写什么，它只明白0和1。**编程语言是为人服务的。**

#### 冗余（Duplication）

冗余代码是非常不好的，所以，不要重复自己，要尽量保持简单易懂，编程的时候要学会“懒惰”：代码只写一次。


上面我已经解释了什么是STUPID代码，你可能觉得自己的代码是STUPID，但是不要紧，别灰心，好好想想，然后通过写出SOLID代码来拯救自己。

### 救星来了：SOLID

SOLID是Robert C.Martin（或被熟知为Uncle Bob）发明的，一组用来描述好的代码应当遵守的设计原则的集合。

SOLID的含义是：

- 单一职责原则（**S**ingle Responsibility Principle）
- 开放封闭原则（**O**pen/Closed Principle）
- 里氏替代原则（**L**iskov Substitution Principle)
- 接口隔离原则（**I**nterface Segregation Principle)
- 依赖倒置原则（**D**ependency Inversion Principle）


#### 单一职责原则（Single Responsibility Principle）

单一职责原则（SRP）认为：每个类都应该只承担单一的职责。**无论任何理由都不应该打破这个约束。**

就算你能把所有功能都加到一个模块里你也不应该这么做。按照划分职责去编程能帮助你设计出更好的代码。每次要往一个类里加逻辑的时候都应该问自己：这个逻辑放在这合适吗？使用**分层**的思想是很有帮助的，尽量把大的类分隔成小类，避免出现一个全知全能的类（God Classes）。最后补充一点：注释要简单直白，任何以“在这种情况下”、“但如果”、“除了”、“或者”开头的注释都是有问题的。

#### 开放封闭原则（Open/Closed Principle）

开放封闭原则（OCP）认为：软件产品应该**对扩展开放，对修改封闭**。

默认情况下，你应该把所有的成员变量都设成**私有的**，只有在需要的时候才去写getter和setter。我之前写过一篇文章，[《 the ninth rule of the Object Calisthenics 》](https://williamdurand.fr/2013/06/03/object-calisthenics/#9-no-getters/setters/properties)已经解释过这个观点。

#### 里氏替代原则（Liskov Substitution Principle)

里氏替代原则（LSP）认为：**程序里的对象应该可以在不影响程序正确性的情况下替换成他们的子类对象。**

来举个例子。一个四边形（Rectangle），有一个属性叫width，一个属性叫height。来看下下面的伪代码：


```
rect = new Rectangle();

rect.width  = 10;
rect.height = 20;

assert 10 == rect.width
assert 20 == rect.height
```

我们简单地把width和height设置给一个四边形对象，然后断言一下两个属性设置的都没有问题。到此为止都很好。

现在我们要进行下一步的定义，规定一个四个边长度都相等的四边形（Rectangle）叫做正方形（Square）。正方形**也是一个**四边形，所以我们创造一个正放心的类来继承四边形的类，然后把上面那段代码的第一行替换成：
```
rect = new Square();
```

根据正方形的定义，它的width和height应该是相等的。那你发现问题了吗？第一局断言就会失败，因为我们肯定会修改正方形类的setter，来让它满足正方形的定义，这就是违反了里氏替换原则。


#### 接口隔离原则（Interface Segregation Principle)

接口隔离原则（ISP）认为：一个为使用者定制的接口比一个更泛用的接口更好。或者说，你永远不应该实现一个你用不到的方法。严格执行接口隔离原则能让你的代码更**低耦合**、更**高内聚**。

每次谈到**耦合**，*内聚*也是一个常被提起的概念。高内聚的意思是说把相思的关联性大的内容放在一起。内聚和耦合结合起来就是正交设计的概念。其主旨是让你的**模块更专注**，并且**最小化他们之间的依赖**

这个原则其实跟单一职责原则（SRP）很相似，一个接口意味着一份需求。可以让一个类实现不沟通的接口，但是记得不要违反单一职责原则。

#### 依赖倒置原则（Dependency Inversion Principle）

依赖导致原则（DIP）有两个关键点：
- 抽象不能依赖于细节；
- 细节应该依赖抽象。
- 
这个原则也可以重申为：在给定层使用同一层的抽象。接口应当依赖于其他的接口。不要给一个接口的签名里增加具体类的依赖。在你的类方法里要使用接口。

要注意到依赖倒置原则跟依赖注入是不一样的。**依赖注入**讲的是如何让一个对象知道另一个依赖对象。或者说，是讲一个对象要如何获取到一个依赖。另一方面，依赖倒置原则（DIP）是关于抽象的层次。而且，一个依赖注入容器是一种把类连接起来的方式，虽然这并不意味着你做了依赖注入。 可以看下[Service Locator](http://en.wikipedia.org/wiki/Service_locator_pattern)做为例子。

与其使用一些强耦合的类，不如使用接口。这叫做**面向接口编程**。这能让代码减少对具体实现的依赖，并使其更**可重用**。这也保证了你可以再不违反接口的外部表现的同事替换具体实现，也符合上面提到的里氏替换原则。

### 结论

你可能注意到了，关键是避免紧耦合。这个原则体现在很多代码里，只要你现在开始只关注解决紧耦合这一个问题，你的代码质量就会马上提高。

如果我最后只能提供一条建议的话，那就是**多动脑子**。在软件工程中有很多的原则，尽管你并不能完全理解所有的原则，也要在写代码之前多进行思考。花时间去理解那些你还不理解的东西。

说实话，写出SOLID的代码并不是很难。
