原文：https://medium.com/@daptronic/mobile-app-versioning-a-numbers-game-f1ea9dbd1ded


# 移动端App版本号规则：数字的游戏

如果你看过App Store或者Play Store给你列出了一个App的详细信息，你会注意到，在这些信息的最下端，越过描述和评论，以及其他App推荐，会有一个看似无关紧要的中等字号写着。。。版本号。

![image](https://miro.medium.com/max/2044/1*5o_PGx-K1wW7YZcK-YP5zg.png)

版本号可能是你能想到的任何数字和字母的任意组合，并且不同的开发者会有不同的命名方法。

![image](https://miro.medium.com/max/2160/1*2cIVM8b3rSATlykL1_GJRQ.jpeg)

不同开发者使用的版本号规则系统是非常不同和自称体系的，几乎没有两个相同的版本号规则。因此，如果你们已经有了一个你们自己的版本号方案，并且在你们的程序的开发、测试、分发过程中起着重要的作用，那么请继续使用它们并且跳过本篇文章的余下部分。但如果你从未真的思考过，版本号到底是什么，或者它可以是什么，起什么作用，那么让我给你一些简单的建议，这些建议可以让你再你app的追踪、测试、发布的方式从此都大不相同。

### 版本号解剖学

对于我来说，一个完美的app版本号（如果真的存在的话），应该包含4个主要部分：Major, Minor, Patch, and Build.

![image](https://miro.medium.com/max/388/1*5pDCF0E7SJtmjumwA765Rg.png)

一个版本号规则系统是建立在应该如何发布和测试你的app上的，那么让我们一个一个的来讨论这每一部分的含义。

#### Major Version

对于一个程序来说，Major Version（主版本号）是一个完全主观的东西，它并不和你开发、测试、发布系统的任何一个具体的步骤相绑定，因此它其实就是一个用来追踪程序的体验或基础组件发生系统性变化的方法。主版本号通常是在你的程序发生戏剧性变化时进行增大。这个变化可以是一个视觉上的重新设计、代码的重构，或者影响体验的一个后端系统的修改。到底哪些改动必须要升级主版本号，这个具体范围完全取决于你，没有一个具体的阈值或规范决定主版本是否需要变动。

对于一个库组件，朱版本号往往标识这一些重大的改动，这些改动往往需要库的使用者主动去进行适配，否则可能会导致程序的崩溃，因此库使用者为了升级到库的最新代码必须要对自己代码进行修改。当库移除了废弃的API，或者做同一件事用一种新的方法替换了老的方法，那么库的主版本号就必须要要升级。

#### Minor Version
minor Version（次版本号）完全是整个版本号里的明星，这一位将是你差不多每次常规迭代版本中都会变更的一位（除了热更新版本之外），一般来说，我倾向于使用双分支版本管理系统，在这个系统里，你应该一直有两个活跃的分支：master分支，所有的开发工作都要进入这里；和一个release分支，每次你要发布代码时要把代码冻结到这个分支里。一旦你在release分支里冻结了一个代码，那么你就应该再master分支里自增次版本号（为了下一次版本发布做准备），同时你的代码要在这个自增后的版本号里冻结不动。但是等等，你会说，如果我们发布前在release分支里发现了一些致命的bug怎么办？很高兴你问了，但是你可以继续往后看，如果你一定要现在知道答案的话，可以先跳到 Build Number这一节。

#### Patch Number

好了，现在你的版本已经发布了，一个用户留下了一条愤怒的评论，突然间这一层楼的每一个行政人员都在给你发消息抱怨你的产品，现在怎么办？你需要拉出最新发布版本的代码，修改一个bug或者问题，在发布一个带着最新修改的新版本。这个版本就是一个hotfix “热修复”版本或者叫patch“补丁”版本， 同时希望这种情况不会太频繁。。。但是它确实会发生，所以你必须为之做好准备。版本号的第三位就是patch number（补丁号），这一位表明，产品的整体版本是不变的，但还有点轻微的不同。

![image](https://miro.medium.com/max/1000/1*qPgf67rGVV-gjf5gM3Q3AQ.jpeg)

补丁号实际的作用是一个安全网，防止你犯了错误而且发出去了。如果在发布版本里发现了致命的错误，你就可以修正这个错误，升一位补丁号，发布一个“打过补丁”的版本。如果下一个新主版本或次版本发布之后，补丁号会要回到0.很显然，补丁号基本应该一直是0，如果你在补丁位看到了高位数字，那说明你的开发流程的某些环节应该存在一些问题。


#### Build Number

Build Number（构建号）就像一个监工，负责日复一日的标识你每一个努力工作而构建的版本。在一个健康的持续集成环境里，你或许应该每天构建一个版本。再极端一点的话，一个极致的有无限资源的持续集成系统甚至应该每一个commit都构建一个版本。这样做的原因是多种多样的：不过最重要的一点可能跟[In-Sprint QA](https://medium.com/p/e3e2eda667ca)有关。每一天开发者都在修改代码和修正bug，而所有这些改动都需要被测试。如果你一次把所有这些改动都丢给测试人员，那么定位问题将是非常痛苦的，它还会给你尝试做的敏捷开发计划泼一盆冷水。相反的，我们更希望每天给测试人员一个构建版本，这样测试工程师就拿到一个修改流而不是一个巨型的改动。但是，测试人员也需要一个方式去知晓哪些构建里有哪些代码改动，那么构建号就要起作用了。构建号是独立于版本号其他部分的，而且是完全唯一的标识一个构建的，这样测试人员就知道他们手上的是什么样的一个构建版本，比如哪些bug被修正了，哪些没有。当开发者修复了一个bug或完成了一个场景，他们可以把这个修复或场景所在的版本的构建号增加，这样测试人员就知道他们要测什么了。这样就消除了开发者和测试者之间的误解，开发人员构建完版本后，测试人员就能在第二天测试他们的版本。

同样，如果你已经更新到了release分支，而测试人员发现了影响发布的bug，你就可以再release分支里修复这个bug（别忘了cherry-pick到master分支里），自增构建号，然后够建一个新的发布版本，不需要更新主版本号或此版本号。

另外，构建号还可以追踪发布版本到底是从哪个代码commit里发布出来的，只要你能保证每次commit都变更一次构建号。

你的app的版本号可以是非常简单的1，2，3，或者也可以像Netfiix那样搞的神秘和难以理解。但不管你如何原则给你的app起版本号，都应该意识到版本号的真正含义和它对梳理你的开发流程右舵重要的好处。预期每次想发布的时候再不停的膨胀你的版本号，不如多想一想版本号能够为你带来什么，并且更多的修改它。

