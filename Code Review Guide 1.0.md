## 1. code review的目的

1.1 保证代码质量

从白盒层面在提测前尽可能发现问题和隐患。很多代码的质量问题，往往不是直接反映在外在交互和性能指标上（甚至不会反应到单元测试上）。很多问题其实需要从代码层面进行审查，尤其是一些短期内没有影响但有长期影响的代码问题上。

1.2 形成代码和设计规范

很多团队在工作规范性问题上往往有两个问题：
- 没有形成统一的规范； 
- 有统一的规范但难以在开发中严格执行。

其实这两方面问题都能够通过code review去解决。首先，code review过程中往往会出现对一个代码段合理性的讨论（需要改还是不需要改），每次讨论最后的结果往往都可以抽象出一条代码规范，而这种代码规范往往比一个自上而下形成的代码规范更具先进性：它是通过团队共识形成的，并且已经被团队成员思考和理解；当形成代码规范之后，code review又是检验团队成员代码是否符合规范的最好方法。

1.3 交叉熟悉代码

code review要求一个review人必须去认真阅读被review的代码，那么熟悉其他成员的代码有两个好处：
- 更多的了解产品整体机制，了解自己负责模块的上下游原理，帮助自己实现优化和方案选择。
- 一段代码的review人其实就成为了这段代码的一个辅负责人，有必要时可以帮助修改问题。

1.4 互相监督/自我监督

code review能让每个人再提交一个merge request时，设计一个接口时，编写一个非常规实现时，甚至命名一个变量时，都会思考这些代码会不会遭到别人质疑，会不会无法通过别人的挑战。这样这些代码在进入code review前，质量就已经提高了。

1.5 交流学习

code review不光是检查别人的问题，也可以学习别人的优秀的设计，细节的考量，以及自己不熟悉的api。


## 规范

### 2. 操作规范
2.1. no one can push

主线代码（master,develop,release）所有的代码都必须经过review，不能直接push；

2.2 resolve all discussions

一个merge request必须在所有comment都被resolve的情况下才能merge。（以上两点可以在gitlab里进行设置强制执行）

2.3 谁comment谁resolve

一个review comment是否resolve要有review comment的编写者来操作，而不由修改代码的开发者来操作。

2.4 需要对comment做出回复。

被review人需要对所有未resolve的comment做出回复。如果修改了代码，则需要回复自己的操作（“已修改”“已删除”），尽量写上自己具体修改内容。如果认为不需要修改代码，则需要回复自己不修改代码的理由。回复后由comment的编写者来决定是否resolve这一comment。

2.5 comment不限内容

review的comment不应当只局限于问题和质疑，任何和当前这段代码相关的内容都是鼓励的，其中不限于：赞扬代码实现巧妙；对业务逻辑的疑问；自己的感想备忘；at其他人，希望其他人参与review或提醒其他人注意这段代码的逻辑，等等。若不是一个需要被reviewer人修改代码的comment（比如赞扬），可以写下comment后马上置为resolved。

2.6 控制merge request体量

一个merge request尽量不要超过20个代码文件。尽量在编写代码时就规划好review的批次，一次merge reuqest尽量只包含一部分功能内容，并且有一定的逻辑完整性。

2.7 增加文字描述

merge request的标题和描述中要尽可能具体描述这次merge request的提交内容，方便review人阅读代码。

2.8 避免冲突

提交merge request最好先合并主线代码，避免提交后出现冲突。

2.9 不能简化git log

为了修改review问题而进行的代码commit，commit log不能简单的写“修改review问题”，要写具体的修改内容。

2.10 明确review范围 

本次review中如果有未完成的功能、测试用的代码，需要在代码中加上注释或者warning（//TODO //TEST)，为review人明确review范围。


## 3. review内容

3.1 功能正确性

功能正确性是code review的底线，也是code review最实用的部分。常见的需要review的功能正确性问题有逻辑判断、执行时机、安全性检查、线程安全、容错处理、持久化等。

3.2 设计

一个功能实现完全符合预期的模块也可能是有严重设计缺陷的，尤其在依赖关系和层次设计上。在整体架构和单独模块的架构上，都要遵循团队预选设定的架构设计方法论，比如MVP、MVVM，在具体功能流程上也要遵循面向对象设计的一些基本原则，如SOLID（单一责任、开放封闭、里氏替换、依赖倒置、接口分离），尤其影响范围较大的模块设计，需要团队多名成员review通过才能合并。

3.3 代码风格

代码风格除了遵循现有代码规范外（如果没有组内成文规范可以参考苹果规范，或参考系统库内代码风格），也要更多的考虑统一性。

3.4 可读性

可读性往往是在review中容易被忽略的一个部分，但实际是极其重要的一部分，可读性不好的代码，往往会给更长期的代码修改维护阶段提高修改成本、增加出错几率。

所以在review过程中，代码编写人可以去给reviewer讲解实现需求，但不应该讲解代码逻辑，而应该由review人通过代码和注释理解代码的流程和用意，任何不能够直接通过代码阅读了解业务逻辑的代码段，都是值得质疑的，可能需要优化命名，重构设计，或者增加注释。一段必须人工解释才能读懂的代码，无法保证在后期本人或他人的维护中不出现理解偏差。

3.5 UI

UI其实是最不容易白盒review的，但却是比较容易在测试阶段和UI校对阶段发现问题的，因此这部分可以更多关注api使用，依赖关系等方面。实际效果可以留到测试人员和设计人员检查。

## 4. review粒度

4.1 尽量保持最细粒度

在一个项目开始前可以预先设定本项目中进行code review的粒度，比如只review正确性，不review代码风格等等。但只要不是时间进度特别紧迫时，都应当保持最细的review粒度，这种细致的review粒度其实会在很快收到成效，可以在短时间内弥补review增加的开发时间。

4.2 紧急情况可以先merge后补充review

有些紧急情况，比如提交内容影响团队其他成员开发，或者影响后续测试，可以适当放宽review粒度，先merge代码再对已经merge的mr进行补充review。但这个放宽也要视情况而定，比如本次review的可能是一个其他成员需要的底层模块，那本次review也要严格review接口设计，可以后续补充对实现的review。


## 5.可能存在的问题

5.1 勿把code review当成“安全带”

1975年萨姆佩兹曼的一项研究表明，自从交通法规强制系安全带之后，每次车祸的死亡人数减少了，但车祸次数却增加了，总体死亡还是增加了，因为系了安全带之后，司机开车感觉更加安全因此更加放肆的开车，导致车祸中行人和非机动车的死伤率提升了。——《曼昆经济学》

code review也有这个问题，有些开发者会认为有了code review，就可以减少自己编写代码时的合理性思考。

因此即使有了code review，团队成员也应当加强自我检查和自测。

5.2 需要想办法增加review人的检查动力

code review的效果往往取决于review人的审查力度，有些人则会因为个人开发时间繁忙或本身技术素养有限而降低review的仔细性。这个往往是code review长期存在的一个问题。

现阶段一个考虑实施的办法是，由A去review B编写的代码，review完成提测后，这部分代码将由A来负责维护和bug修改，这样就强制A必须读懂B的代码，并且严格要求B修改代码中不合理的部分。




